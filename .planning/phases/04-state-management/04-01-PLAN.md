---
phase: 04-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/test_state_integration.py
  - backend/tests/fixtures/state_fixtures.py
autonomous: true

must_haves:
  truths:
    - "Checkpoint saves persist pages visited, queued, and entities count"
    - "Pause operation saves checkpoint and updates status to PAUSED"
    - "Resume operation loads checkpoint and continues from saved state"
    - "Full flow works: start -> pause -> checkpoint -> resume -> complete"
    - "Checkpoint persists every 10 pages or 2 minutes (configurable intervals)"
    - "Paused duration tracked accurately across multiple pause/resume cycles"
  artifacts:
    - path: "backend/tests/test_state_integration.py"
      provides: "Integration tests for full checkpoint/resume flow"
      min_lines: 250
    - path: "backend/tests/fixtures/state_fixtures.py"
      provides: "Shared fixtures for state management testing"
      min_lines: 80
  key_links:
    - from: "CheckpointService"
      to: "CrawlSession.checkpoint_data"
      via: "save_checkpoint()"
      pattern: "checkpoint_data"
    - from: "ProgressService"
      to: "CheckpointService"
      via: "pause_job() -> save_checkpoint()"
      pattern: "pause_job|save_checkpoint"
    - from: "JobService"
      to: "ProgressService"
      via: "recover_in_progress_jobs()"
      pattern: "recover_in_progress|resume_from_checkpoint"
---

<objective>
Create integration tests for the checkpoint/resume flow that verify all state management components work together correctly.

Purpose: Validate that existing CheckpointService, ProgressService, and JobService implementations meet Phase 4 requirements (STA-01 through STA-05) when components are integrated, catching wiring issues that unit tests miss.

Output: Integration test file with mock Redis exercising full checkpoint/pause/resume flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-state-management/04-RESEARCH.md
@backend/app/services/checkpoint_service.py
@backend/app/services/progress_service.py
@backend/app/services/job_service.py
@backend/app/services/redis_service.py
@backend/app/models/company.py
@backend/app/models/enums.py
@backend/tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state management integration test fixtures</name>
  <files>backend/tests/fixtures/state_fixtures.py</files>
  <action>
Create shared fixtures for state management integration testing at `backend/tests/fixtures/state_fixtures.py`:

1. If `backend/tests/fixtures/__init__.py` doesn't exist, create it (empty file)

2. Create `backend/tests/fixtures/state_fixtures.py` with:

   - `MOCK_CHECKPOINT_DATA`: Dict simulating a saved checkpoint containing:
     - `pagesVisited`: List of 15 visited URLs
     - `pagesQueued`: List of 5 queued URLs
     - `externalLinksFound`: List of 3 external links
     - `currentDepth`: 2
     - `entitiesExtractedCount`: 42
     - `analysisSectionsCompleted`: ['executive_summary', 'company_overview']
     - `crawlStartTime`: ISO timestamp
     - `lastCheckpointTime`: ISO timestamp

   - `MOCK_PROGRESS_DATA`: Dict simulating progress tracking:
     - `pagesCrawled`: 15
     - `pagesTotal`: 25
     - `entitiesExtracted`: 42
     - `tokensUsed`: 5000
     - `timeElapsed`: 120
     - `currentActivity`: 'Crawling page 16 of 25'

   - `create_company_with_crawl_session(db, status='in_progress')`: Factory function that:
     - Creates a Company record with specified status
     - Creates a CrawlSession with pages_crawled, pages_queued
     - Creates some Page records for the session
     - Sets processing_phase to CRAWLING
     - Returns (company, crawl_session) tuple

   - `create_paused_company_with_checkpoint(db)`: Factory function that:
     - Creates a Company with status=PAUSED, paused_at set
     - Creates CrawlSession with status=PAUSED and checkpoint_data populated
     - Returns (company, crawl_session) tuple

   - `MockRedisService`: Mock class that:
     - Stores data in memory dict
     - Implements get_progress(), set_progress()
     - Implements get_job_status(), set_job_status()
     - Implements acquire_lock(), release_lock(), extend_lock()
     - Tracks call_log for verification

   - `CHECKPOINT_INTERVALS`: Dict with test values:
     - `PAGE_INTERVAL`: 10
     - `TIME_INTERVAL_SECONDS`: 120
     - `DEFAULT_TIMEOUT_SECONDS`: 3600

Use pytest fixture patterns that can be imported into test files.
  </action>
  <verify>
```bash
cd /Users/stephenhollifield/Cira && python3 -c "from backend.tests.fixtures.state_fixtures import MOCK_CHECKPOINT_DATA, MockRedisService, create_company_with_crawl_session; print('State fixtures import OK')"
```
  </verify>
  <done>Fixture module exists with mock checkpoint data and Redis service for state management testing.</done>
</task>

<task type="auto">
  <name>Task 2: Create checkpoint/resume integration tests</name>
  <files>backend/tests/test_state_integration.py</files>
  <action>
Create integration tests that verify the full checkpoint/resume flow in `backend/tests/test_state_integration.py`:

1. **Test class: TestCheckpointSave (STA-01)**

   - `test_saves_checkpoint_after_page_interval` (STA-01):
     - Create company with crawl session
     - Simulate 10 pages crawled
     - Call checkpoint_service.save_checkpoint()
     - Assert checkpoint_data populated in CrawlSession
     - Assert pagesVisited contains all 10 URLs

   - `test_saves_checkpoint_after_time_interval` (STA-01):
     - Create company with crawl session
     - Mock time to be 2+ minutes since last checkpoint
     - Call progress_service.should_checkpoint()
     - Assert returns True
     - Assert checkpoint saved includes timestamp

   - `test_checkpoint_includes_all_required_fields`:
     - Save checkpoint with pages, entities, sections
     - Load checkpoint
     - Assert all fields present: pagesVisited, pagesQueued, externalLinksFound, currentDepth, entitiesExtractedCount, analysisSectionsCompleted

   - `test_checkpoint_preserves_existing_data_on_update`:
     - Save checkpoint with 5 pages
     - Add 5 more pages
     - Save again
     - Assert all 10 pages preserved

2. **Test class: TestPauseOperation (STA-02)**

   - `test_pause_updates_company_status` (STA-02):
     - Create in_progress company
     - Call progress_service.pause_job()
     - Assert company.status == PAUSED
     - Assert company.paused_at set

   - `test_pause_saves_checkpoint`:
     - Create company with pages crawled
     - Call pause_job()
     - Assert checkpoint_data populated
     - Assert checkpoint has current progress

   - `test_pause_updates_crawl_session_status`:
     - Create company with active crawl session
     - Call pause_job()
     - Assert crawl_session.status == PAUSED

   - `test_pause_only_allowed_from_in_progress`:
     - Create company with status=COMPLETED
     - Attempt pause_job()
     - Assert raises InvalidStateError or returns error

   - `test_pause_acquires_and_releases_lock`:
     - Mock RedisService
     - Call pause_job()
     - Assert acquire_lock called
     - Assert release_lock called

3. **Test class: TestResumeOperation (STA-03)**

   - `test_resume_updates_company_status` (STA-03):
     - Create paused company with checkpoint
     - Call progress_service.resume_job()
     - Assert company.status == IN_PROGRESS
     - Assert company.paused_at cleared

   - `test_resume_loads_checkpoint`:
     - Create paused company with checkpoint (15 pages visited, 5 queued)
     - Call resume_job()
     - Assert can access visited pages
     - Assert can access queued pages

   - `test_resume_calculates_paused_duration`:
     - Create paused company with paused_at = 5 minutes ago
     - Call resume_job()
     - Assert total_paused_duration_ms increased by ~300000ms

   - `test_resume_accumulates_paused_duration`:
     - Pause (5 min), resume, pause (3 min), resume
     - Assert total_paused_duration_ms ~= 8 minutes

   - `test_resume_updates_crawl_session_status`:
     - Create paused company with paused session
     - Call resume_job()
     - Assert crawl_session.status == ACTIVE

   - `test_resume_only_allowed_from_paused`:
     - Create company with status=COMPLETED
     - Attempt resume_job()
     - Assert raises InvalidStateError or returns error

4. **Test class: TestFullFlow**

   - `test_start_pause_resume_complete_flow`:
     - Create pending company
     - Start job (IN_PROGRESS)
     - Simulate 10 pages crawled
     - Pause job (PAUSED, checkpoint saved)
     - Wait simulated 2 minutes
     - Resume job (IN_PROGRESS, checkpoint loaded)
     - Simulate remaining pages
     - Complete job (COMPLETED)
     - Assert final state correct
     - Assert total_paused_duration_ms tracked

   - `test_multiple_pause_resume_cycles`:
     - Start -> Pause -> Resume -> Pause -> Resume -> Complete
     - Assert each checkpoint preserves cumulative progress
     - Assert no data lost between cycles

   - `test_checkpoint_persists_analysis_progress`:
     - Start job through to analyzing phase
     - Complete 3 of 7 sections
     - Pause
     - Assert checkpoint includes analysisSectionsCompleted
     - Resume
     - Assert can continue from section 4

5. **Test class: TestCheckpointValidation**

   - `test_handles_corrupted_checkpoint_data`:
     - Save checkpoint with invalid JSON
     - Load checkpoint
     - Assert graceful handling (returns defaults or repairs)

   - `test_handles_missing_checkpoint_fields`:
     - Save checkpoint missing pagesVisited
     - Load checkpoint
     - Assert defaults applied

   - `test_checkpoint_version_migration`:
     - Create checkpoint with old version format
     - Load checkpoint
     - Assert migrated to current version

6. Use `@pytest.fixture` to provide mock Redis and database fixtures.

7. Mock time where needed for testing intervals.

8. Each test should be independent and use database fixtures.
  </action>
  <verify>
```bash
cd /Users/stephenhollifield/Cira && python3 -m pytest backend/tests/test_state_integration.py -v --tb=short 2>&1 | head -80
```
  </verify>
  <done>All integration tests pass, verifying STA-01 through STA-03 requirements are met by existing implementation.</done>
</task>

</tasks>

<verification>
Run all integration tests to verify checkpoint/resume flow works end-to-end:

```bash
cd /Users/stephenhollifield/Cira && python3 -m pytest backend/tests/test_state_integration.py -v
```

Expected: All tests pass, demonstrating requirements STA-01 through STA-03 are satisfied.
</verification>

<success_criteria>
- [ ] Fixture module provides mock checkpoint data and Redis service
- [ ] Integration tests cover checkpoint save (STA-01)
- [ ] Integration tests cover pause operation (STA-02)
- [ ] Integration tests cover resume operation (STA-03)
- [ ] Tests verify component wiring (CheckpointService -> ProgressService -> JobService)
- [ ] All tests pass with existing implementation
- [ ] Tests are documented with requirement traceability in docstrings
</success_criteria>

<output>
After completion, create `.planning/phases/04-state-management/04-01-SUMMARY.md`
</output>
