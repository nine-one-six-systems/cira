---
phase: 04-state-management
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/test_state_edge_cases.py
autonomous: true

must_haves:
  truths:
    - "System handles timeout gracefully with partial results preserved"
    - "System automatically recovers in_progress jobs on startup"
    - "Concurrent pause/resume requests handled safely with locking"
    - "Stale jobs detected and handled after extended inactivity"
    - "Recovery from checkpoint works after crash/restart"
    - "Lock expiry prevents deadlocks"
  artifacts:
    - path: "backend/tests/test_state_edge_cases.py"
      provides: "Edge case and robustness tests for state management"
      min_lines: 250
  key_links:
    - from: "JobService"
      to: "recover_in_progress_jobs()"
      via: "startup recovery"
      pattern: "recover_in_progress|_is_stale_job"
    - from: "ProgressService"
      to: "handle_timeout()"
      via: "timeout handling"
      pattern: "handle_timeout|is_timeout|get_remaining_time"
    - from: "RedisService"
      to: "acquire_lock/release_lock"
      via: "distributed locking"
      pattern: "acquire_lock|release_lock|LOCK_EXPIRY"
---

<objective>
Create edge case tests that validate state management robustness, timeout handling, and recovery scenarios.

Purpose: Ensure the state management system handles unusual conditions, concurrent operations, timeouts, and recovery gracefully without data corruption or deadlocks.

Output: Edge case test file covering timeouts, concurrency, recovery, and failure scenarios.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-state-management/04-RESEARCH.md
@backend/app/services/job_service.py
@backend/app/services/progress_service.py
@backend/app/services/redis_service.py
@backend/app/services/checkpoint_service.py
@backend/tests/test_crawl_edge_cases.py
@backend/tests/test_extraction_edge_cases.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state management edge case tests</name>
  <files>backend/tests/test_state_edge_cases.py</files>
  <action>
Create edge case tests at `backend/tests/test_state_edge_cases.py`:

1. **Test class: TestTimeoutHandling (STA-05)**

   - `test_timeout_preserves_partial_results` (STA-05):
     - Create company with 15 pages crawled
     - Trigger timeout via progress_service.handle_timeout()
     - Assert pages are preserved
     - Assert entities are preserved
     - Assert checkpoint saved with progress

   - `test_timeout_sets_appropriate_status`:
     - Create in_progress company
     - Trigger timeout
     - Assert company.status == FAILED or specific timeout status
     - Assert crawl_session.status == TIMEOUT or FAILED

   - `test_is_timeout_detects_exceeded_time`:
     - Create company with started_at = 2 hours ago
     - Configure timeout = 1 hour
     - Assert progress_service.is_timeout() returns True

   - `test_is_timeout_excludes_paused_duration`:
     - Create company started 90min ago with 30min paused
     - Configure timeout = 1 hour
     - Assert is_timeout() returns False (60min active < 1hr)

   - `test_get_remaining_time_calculates_correctly`:
     - Create company with started_at = 30min ago, timeout = 1hr
     - Assert get_remaining_time() ~= 1800 seconds

   - `test_timeout_logs_reason`:
     - Trigger timeout
     - Assert appropriate log message recorded

   - `test_can_resume_after_timeout`:
     - Timeout a job with progress preserved
     - Manually set status to PAUSED
     - Assert can resume from checkpoint

2. **Test class: TestAutomaticRecovery (STA-04)**

   - `test_recovers_in_progress_jobs_on_startup` (STA-04):
     - Create 2 companies with status=IN_PROGRESS
     - Call job_service.recover_in_progress_jobs()
     - Assert both companies processed
     - Assert dispatch or recovery actions taken

   - `test_recovery_skips_recently_active_jobs`:
     - Create company with status=IN_PROGRESS, recent activity
     - Call recover_in_progress_jobs()
     - Assert job not marked as stale
     - Assert job dispatched for continuation

   - `test_recovery_fails_stale_jobs`:
     - Create company with status=IN_PROGRESS, no activity for 2+ hours
     - Call recover_in_progress_jobs()
     - Assert company.status == FAILED
     - Assert appropriate failure reason logged

   - `test_recovery_respects_checkpoints`:
     - Create IN_PROGRESS company with checkpoint (10 pages)
     - Simulate restart
     - Call recover_in_progress_jobs()
     - Assert recovery continues from page 10

   - `test_recovery_handles_company_without_checkpoint`:
     - Create IN_PROGRESS company with no checkpoint
     - Call recover_in_progress_jobs()
     - Assert job restarted from beginning or queued

   - `test_is_stale_job_threshold`:
     - Create job with last activity 30min ago
     - Assert _is_stale_job() returns False (under 1hr threshold)
     - Create job with last activity 90min ago
     - Assert _is_stale_job() returns True

   - `test_recovery_runs_once_on_startup`:
     - Mock before_request handler
     - Assert recovery only runs on first request
     - Assert subsequent requests don't re-trigger

3. **Test class: TestConcurrentOperations**

   - `test_concurrent_pause_requests_handled_safely`:
     - Create in_progress company
     - Simulate 2 concurrent pause requests
     - Assert only one succeeds (lock prevents race)
     - Assert company ends in PAUSED state

   - `test_concurrent_resume_requests_handled_safely`:
     - Create paused company
     - Simulate 2 concurrent resume requests
     - Assert only one succeeds
     - Assert company ends in IN_PROGRESS state

   - `test_pause_during_checkpoint_save`:
     - Mock slow checkpoint save
     - Issue pause during save
     - Assert checkpoint completes before status change
     - Assert no data corruption

   - `test_lock_prevents_parallel_state_changes`:
     - Create in_progress company
     - Acquire lock manually
     - Attempt pause (should wait or fail)
     - Release lock
     - Attempt pause again (should succeed)

   - `test_lock_expiry_prevents_deadlock`:
     - Create company
     - Acquire lock, don't release (simulate crash)
     - Wait for lock expiry (60s in test mock)
     - Assert new operation can acquire lock

   - `test_multiple_companies_pausable_simultaneously`:
     - Create 3 in_progress companies
     - Pause all simultaneously
     - Assert all 3 end in PAUSED state
     - Assert no cross-contamination

4. **Test class: TestCheckpointRecovery**

   - `test_recovery_from_corrupted_checkpoint`:
     - Create company with invalid JSON in checkpoint_data
     - Attempt to load checkpoint
     - Assert graceful handling (defaults or skip)
     - Assert no exception thrown

   - `test_recovery_from_partial_checkpoint`:
     - Create checkpoint missing pagesQueued
     - Load checkpoint
     - Assert pagesQueued defaults to empty list

   - `test_checkpoint_migration_on_load`:
     - Create checkpoint with version=0 format
     - Load checkpoint
     - Assert migrated to version=1 format

   - `test_checkpoint_survives_database_reconnect`:
     - Save checkpoint
     - Simulate DB connection drop and reconnect
     - Load checkpoint
     - Assert data intact

5. **Test class: TestErrorRecovery**

   - `test_pause_error_doesnt_corrupt_state`:
     - Create in_progress company
     - Mock DB error during pause
     - Assert company still IN_PROGRESS (rollback)
     - Assert can retry pause

   - `test_resume_error_doesnt_corrupt_state`:
     - Create paused company
     - Mock DB error during resume
     - Assert company still PAUSED
     - Assert checkpoint intact

   - `test_redis_unavailable_during_pause`:
     - Mock Redis connection error
     - Attempt pause
     - Assert appropriate error returned
     - Assert database state unchanged

   - `test_redis_unavailable_during_progress`:
     - Mock Redis connection error
     - GET /progress
     - Assert falls back to DB-only progress or error

   - `test_handles_missing_crawl_session`:
     - Create company with no crawl session
     - Attempt pause
     - Assert graceful handling (error or no-op)

6. **Test class: TestProgressEdgeCases**

   - `test_progress_with_zero_pages`:
     - Create company with 0 pages crawled, 0 queued
     - GET progress
     - Assert pagesCrawled=0, pagesTotal=0
     - Assert no division by zero

   - `test_progress_with_completed_company`:
     - Create completed company
     - GET progress
     - Assert shows 100% or appropriate completed state

   - `test_progress_with_failed_company`:
     - Create failed company
     - GET progress
     - Assert status=failed returned

   - `test_progress_time_calculation_overflow`:
     - Create company started 1000 hours ago
     - GET progress
     - Assert no integer overflow
     - Assert reasonable time display

   - `test_progress_with_very_large_token_count`:
     - Create company with total_tokens_used = 10_000_000
     - GET progress
     - Assert tokensUsed returned correctly

7. **Test class: TestStatusTransitions**

   - `test_all_valid_transitions`:
     - PENDING -> IN_PROGRESS (start)
     - IN_PROGRESS -> PAUSED (pause)
     - IN_PROGRESS -> COMPLETED (complete)
     - IN_PROGRESS -> FAILED (error/timeout)
     - PAUSED -> IN_PROGRESS (resume)
     - COMPLETED -> PENDING (rescan)

   - `test_invalid_transitions_rejected`:
     - PENDING -> PAUSED (can't pause before start)
     - COMPLETED -> IN_PROGRESS (can't resume completed)
     - FAILED -> PAUSED (can't pause failed)
     - PAUSED -> COMPLETED (can't complete while paused)

8. Use `@pytest.fixture` for mock services.

9. Organize tests with clear class-based grouping matching test_extraction_edge_cases.py pattern.

10. Mock Redis, time, and database errors where appropriate.
  </action>
  <verify>
```bash
cd /Users/stephenhollifield/Cira && python3 -m pytest backend/tests/test_state_edge_cases.py -v --tb=short 2>&1 | head -80
```
  </verify>
  <done>All edge case tests pass, demonstrating state management is robust against timeouts, concurrency issues, and recovery scenarios.</done>
</task>

</tasks>

<verification>
Run edge case tests to verify robustness:

```bash
cd /Users/stephenhollifield/Cira && python3 -m pytest backend/tests/test_state_edge_cases.py -v
```

Expected: All tests pass, demonstrating STA-04 and STA-05 requirements are satisfied.
</verification>

<success_criteria>
- [ ] Timeout handling preserves partial results (STA-05)
- [ ] Automatic recovery works on startup (STA-04)
- [ ] Concurrent operations handled safely with locking
- [ ] Stale job detection works correctly
- [ ] Checkpoint corruption handled gracefully
- [ ] Error recovery doesn't corrupt state
- [ ] Valid/invalid state transitions tested
</success_criteria>

<output>
After completion, create `.planning/phases/04-state-management/04-03-SUMMARY.md`
</output>
